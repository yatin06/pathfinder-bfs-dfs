{"version":3,"sources":["webpack:///webpack/bootstrap 43679f54d1ef8e33be34","webpack:///./lib/maze.js","webpack:///./lib/path.js","webpack:///./lib/node.js","webpack:///./lib/stack.js","webpack:///./lib/queue.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB,GAAG,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB,EAAE;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC,mBAAmB,eAAe;AAClC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,cAAc,EAAE;AAC/C;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpLA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA,iBAAiB,YAAY;AAC7B,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC1BA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 43679f54d1ef8e33be34","import { calculatePath } from './path.js';\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  let maze = mazeOne;\n  setUpMap(mazeOne);\n  let resetButton = document.getElementById('reset');\n  resetButton.addEventListener(\"click\", () => {\n    reset(maze);\n  });\n\n  let mazeOneButton = document.getElementById('maze-1');\n  mazeOneButton.addEventListener(\"click\", () => {\n    $('#play').off('click');\n    $('#play').attr(\"disabled\", false);\n    maze = mazeOne;\n    setUpMap(mazeOne);\n  });\n\n  let mazeTwoButton = document.getElementById('maze-2');\n  mazeTwoButton.addEventListener(\"click\", () => {\n    $('#play').off('click');\n    $('#play').attr(\"disabled\", false);\n    maze = mazeTwo;\n    setUpMap(mazeTwo);\n  });\n\n  let mazeThreeButton = document.getElementById('maze-3');\n  mazeThreeButton.addEventListener(\"click\", () => {\n    $('#play').off('click');\n    $('#play').attr(\"disabled\", false);\n    maze = mazeThree;\n    setUpMap(mazeThree);\n  });\n});\n\nconst reset = (maze) => {\n  setUpMap(maze);\n  $('#play').attr(\"disabled\", false);\n};\n\nconst setUpMap = (maze) => {\n  let map = makeMap(maze, 25, 25);\n  let rendererOne = makeRenderer(map, 'bfs-graph', 'white', '#383838');\n  let rendererTwo = makeRenderer(map, 'dfs-graph', 'white', '#383838');\n  drawMap(rendererOne, map);\n  drawMap(rendererTwo, map);\n  let startPos = '0,0';\n  let targetPos = `${map.data.length - 1},${map.data.length - 1}`;\n  let pathBFS = [];\n  let pathDFS = [];\n  drawPath(rendererOne, makePoint(startPos), map.cellWidth, map.cellHeight, 'yellow');\n  drawPath(rendererOne, makePoint(targetPos), map.cellWidth, map.cellHeight, '#0f0');\n  drawPath(rendererTwo, makePoint(startPos), map.cellWidth, map.cellHeight, 'yellow');\n  drawPath(rendererTwo, makePoint(targetPos), map.cellWidth, map.cellHeight, '#0f0');\n  pathBFS = calculatePath(map, startPos, targetPos, 'bfs');\n  pathDFS = calculatePath(map, startPos, targetPos, 'dfs');\n  $(\"#play\").on(\"click\", () => {\n    $('#play').attr(\"disabled\", true);\n    $('#reset').attr(\"disabled\", true);\n    runPath(100, pathBFS[0], pathBFS[1], rendererOne, map, startPos, targetPos);\n    runPath(100, pathDFS[0], pathDFS[1], rendererTwo, map, startPos, targetPos);\n  });\n};\n\nconst makeMap = (mazeData, width, height) => (\n    {\n      data: mazeData,\n  \t\twidth: mazeData[0].length,\n  \t\theight: mazeData.reduce(function(acc, row){ return acc + 1; }, 0),\n  \t\tcellWidth: width,\n  \t\tcellHeight: height\n    }\n);\n\nconst makeRenderer = (map, id, primaryColor, secondaryColor) => {\n  const canvasEl = document.getElementById(id);\n  canvasEl.width = map.cellWidth * map.width;\n\tcanvasEl.height = map.cellHeight * map.height;\n\treturn {\n\t\tcanvasEl: canvasEl,\n\t\tctx: canvasEl.getContext('2d'),\n\t\tprimaryColor: primaryColor,\n\t\tsecondaryColor: secondaryColor,\n\t};\n};\n\nconst drawMap = (renderer, map) => {\n    let ctx = renderer.ctx;\n  \tlet canvas = renderer.canvasEl;\n  \tctx.clearRect(0, 0, canvas.width, canvas.height);\n  \tfor (let y = 0; y < map.height; y++) {\n  \t\tfor (let x = 0; x < map.width; x++) {\n  \t\t\tlet cellType = map.data[y][x];\n  \t\t\tif (cellType === 1) {\n  \t\t\t\tctx.fillStyle = renderer.secondaryColor;\n  \t\t\t} else {\n  \t\t\t\tctx.fillStyle = renderer.primaryColor;\n  \t\t\t}\n  \t\t\tctx.fillRect(x * map.cellWidth, y * map.cellHeight,\n          map.cellWidth, map.cellHeight);\n        ctx.strokeStyle=\"black\";\n        ctx.strokeRect(x * map.cellWidth, y * map.cellHeight,\n          map.cellWidth, map.cellHeight);\n  \t\t}\n  \t}\n};\n\nconst drawPath = (renderer, point, width, height, color) => {\n  renderer.ctx.fillStyle = color;\n  renderer.ctx.fillRect(point[0] * width, point[1] * height, width, height);\n  renderer.ctx.strokeStyle=\"black\";\n  renderer.ctx.strokeRect(point[0] * width, point[1] * height, width, height);\n};\n\nconst runPath = (num, path, optimal, renderer, map, startPos, targetPos) => {\n  let pos = 0;\n  \tfunction render(){\n  \t\tif (pos < path.length) {\n  \t\t\tdrawPath(renderer, makePoint(path[pos]), map.cellWidth, map.cellHeight, '#b5c1ff');\n  \t\t} else {\n  \t\t\tdrawPath(renderer, makePoint(targetPos), map.cellWidth, map.cellHeight, 'blue');\n        optimal.forEach((posi) => {\n          drawPath(renderer, makePoint(posi), map.cellWidth, map.cellHeight, 'blue');\n          $('#reset').attr(\"disabled\", false);\n        });\n  \t\t\treturn;\n  \t\t}\n  \t\tpos += 1;\n  \t\tsetTimeout(render, num);\n  \t}\n  \trenderer.ctx.globalAlpha = 0.55;\n  \treturn render();\n};\n\nconst makePoint = (point) => (\n  point.split(',').map((v) => { return v | 0; })\n);\n\n\nlet mazeTwo = [[0,1,0,0,0,1,0,1,1,1,0,1],\n               [0,0,0,1,0,1,0,1,1,0,0,0],\n               [1,0,0,0,0,0,0,0,1,0,0,1],\n               [0,0,1,1,0,0,1,0,0,0,0,1],\n               [0,1,0,0,0,0,1,1,1,1,1,1],\n               [1,0,0,1,0,0,0,1,1,0,1,0],\n               [0,0,0,1,1,0,0,0,0,0,0,0],\n               [0,1,0,0,0,1,0,1,1,0,1,0],\n               [1,1,0,0,0,1,0,0,1,0,1,1],\n               [1,1,0,1,0,1,0,0,1,0,1,0],\n               [0,0,0,1,1,1,0,1,1,0,1,0],\n               [0,1,0,1,1,1,0,0,1,0,0,0]];\nlet mazeThree = [[0,1,0,1,0,0,0,1,0],\n                 [0,0,0,0,1,0,1,0,1],\n                 [1,0,0,0,0,1,0,0,0],\n                 [0,0,1,0,0,0,0,1,0],\n                 [0,0,0,1,1,0,0,0,0],\n                 [1,0,0,1,0,1,1,0,1],\n                 [0,1,0,0,0,1,0,0,1],\n                 [1,1,0,0,1,0,1,0,0],\n                 [0,1,1,0,1,0,0,0,0]];\nlet mazeOne = [\n[0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],\n[1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1],\n[1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1],\n[1,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1],\n[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1],\n[1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1],\n[1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1,1,1],\n[1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1],\n[1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,0,1,0,1],\n[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1],\n[1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1],\n[1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1],\n[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1],\n[1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1],\n[1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1],\n[1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1],\n[1,0,1,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1],\n[1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1],\n[1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,0,0]\n];\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/maze.js\n// module id = 0\n// module chunks = 0","import Node from './node.js';\nimport Stack from './stack.js';\nimport Queue from './queue.js';\n\nexport const calculatePath = (map, startPos, targetPos, algorithm) => {\n  let graph = makeGraph(map.data, map.width, map.height);\n  let startNode = getNodeById(graph, startPos);\n  let targetNode = getNodeById(graph, targetPos);\n  let path = [];\n  let cameFrom = {};\n  let current = startNode;\n  if (algorithm === 'dfs') {\n    let stack = new Stack();\n    stack.push(startNode);\n    cameFrom[startNode.id] = null;\n    while (true) {\n      current = stack.top();\n      path.push(current.id);\n      current.visited = true;\n      if (current.id === targetNode.id) {\n        break;\n      }\n      let unvisited = 0;\n      current.adj.forEach((id) => {\n        let node = getNodeById(graph, id);\n        if (!node.visited) {\n          if (cameFrom[id]) {\n          } else {\n            cameFrom[id] = current.id;\n          }\n          stack.push(node);\n          unvisited += 1;\n        }\n      });\n      if (unvisited === 0) {\n        stack.pop();\n      }\n    }\n  } else if (algorithm === 'bfs') {\n    let queue = new Queue();\n    queue.enqueue(startNode);\n    cameFrom[startNode.id] = null;\n    while (true) {\n      current = queue.dequeue();\n      current.visited = true;\n      path.push(current.id);\n      if (current.id === targetNode.id) {\n        break;\n      }\n      current.adj.forEach((id) => {\n        if (cameFrom[id]) {\n        } else {\n          cameFrom[id] = current.id;\n        }\n\n        let node = getNodeById(graph, id);\n        if (!node.visited) {\n          node.visited = true;\n          queue.enqueue(node);\n        }\n      });\n    }\n  }\n  let optimal = buildOptimal(cameFrom, targetPos);\n  return [path, optimal];\n};\n\nconst makeGraph = (map, width, height) => {\n  let graph = [];\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      if (map[y][x] === 1) {\n        continue;\n      }\n      let adj = [];\n      if ((y - 1 > 0) && map[y - 1][x] === 0) {\n\t\t\t\t\tadj.push('' + x + ',' + (y - 1));\n\t\t\t\t}\n\t\t\t\tif ((y + 1 < map.length) && map[y + 1][x] === 0) {\n\t\t\t\t\tadj.push('' + x + ',' + (y + 1));\n\t\t\t\t}\n\t\t\t\tif ((x - 1 > 0) && map[y][x - 1] === 0) {\n\t\t\t\t\tadj.push('' + (x - 1) + ',' + y);\n\t\t\t\t}\n\t\t\t\tif ((x + 1 < map[y].length) && map[y][x + 1] === 0) {\n\t\t\t\t\tadj.push('' + (x + 1) + ',' + y);\n\t\t\t\t}\n\t\t\t\tgraph.push(new Node('' + x + ',' + y, adj));\n    }\n  }\n  return graph;\n};\n\nconst getNodeById = (graph, nodeId) => {\n  return graph.reduce((out, node) => {\n    if (node.id === nodeId) {\n      out = node;\n    }\n    return out;\n  });\n};\n\nconst buildOptimal = (cameFrom, targetPos) => {\n  if(!cameFrom[targetPos]) {\n    return null;\n  }\n\n  let current = targetPos;\n  let path = [];\n\n  while(current) {\n    path.unshift(current);\n    current = cameFrom[current];\n  }\n\n  return path;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/path.js\n// module id = 1\n// module chunks = 0","class Node {\n  constructor(id, adj){\n    this.id = id;\n\t\tthis.adj = adj;\n  }\n}\n\nexport default Node;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/node.js\n// module id = 2\n// module chunks = 0","class Stack {\n  constructor(){\n    this.items = [];\n    this.length = this.items.length;\n  }\n\n  push(ele){\n    this.length += 1;\n    return this.items.push(ele);\n  }\n\n  pop(){\n    if (this.length > 0) {\n      this.length -= 1;\n    }\n    return this.items.pop();\n  }\n\n  top(){\n    if (this.length > 0) {\n      return this.items[this.length - 1];\n    }\n    return undefined;\n  }\n}\n\nexport default Stack;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/stack.js\n// module id = 3\n// module chunks = 0","class Queue {\n  constructor(ele){\n    if (ele instanceof Array) {\n\t\t\tthis.items = ele;\n\t\t} else {\n\t\t\tthis.items = [];\n\t\t}\n\t\tthis.length = this.items.length;\n  }\n\n  enqueue(ele){\n    this.length += 1;\n\t\treturn this.items.push(ele);\n  }\n\n  dequeue(){\n    if (this.length > 0) {\n\t\t\tthis.length -= 1;\n\t\t}\n\t\treturn this.items.shift();\n  }\n}\n\nexport default Queue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/queue.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}